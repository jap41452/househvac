<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Story House Builder</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Insulation options with R-values and properties
        const INSULATION_OPTIONS = [
            { id: 'none', name: 'No Insulation', rValue: 0, cost: 0, color: 0xe5e7eb },
            { id: 'fiberglass-r13', name: 'Fiberglass Batt R-13', rValue: 13, cost: 0.50, color: 0xfbbf24 },
            { id: 'fiberglass-r19', name: 'Fiberglass Batt R-19', rValue: 19, cost: 0.75, color: 0xf59e0b },
            { id: 'fiberglass-r21', name: 'Fiberglass Batt R-21', rValue: 21, cost: 0.90, color: 0xd97706 },
            { id: 'spray-foam-r25', name: 'Spray Foam R-25', rValue: 25, cost: 2.00, color: 0x10b981 },
            { id: 'spray-foam-r30', name: 'Spray Foam R-30', rValue: 30, cost: 2.50, color: 0x059669 },
            { id: 'rigid-foam-r20', name: 'Rigid Foam R-20', rValue: 20, cost: 1.50, color: 0x3b82f6 },
        ];

        // Wall exterior material options
        const EXTERIOR_MATERIALS = [
            { id: 'brick-red', name: 'Red Brick', cost: 8.50, color: 0x8B4513 },
            { id: 'brick-tan', name: 'Tan Brick', cost: 8.50, color: 0xD2B48C },
            { id: 'vinyl-white', name: 'White Vinyl Siding', cost: 3.50, color: 0xF5F5F5 },
            { id: 'vinyl-gray', name: 'Gray Vinyl Siding', cost: 3.50, color: 0x808080 },
            { id: 'vinyl-beige', name: 'Beige Vinyl Siding', cost: 3.50, color: 0xF5F5DC },
            { id: 'clapboard-white', name: 'White Clapboard', cost: 5.00, color: 0xFAFAFA },
            { id: 'clapboard-blue', name: 'Blue Clapboard', cost: 5.00, color: 0x4682B4 },
            { id: 'stucco-white', name: 'White Stucco', cost: 6.00, color: 0xFFFFF0 },
            { id: 'stucco-tan', name: 'Tan Stucco', cost: 6.00, color: 0xD2B48C },
            { id: 'stone-gray', name: 'Gray Stone', cost: 12.00, color: 0x708090 },
        ];

        // Roof material options
        const ROOF_MATERIALS = [
            { id: 'asphalt-black', name: 'Black Asphalt Shingles', cost: 3.50, color: 0x2F2F2F, reflectivity: 0.05 },
            { id: 'asphalt-gray', name: 'Gray Asphalt Shingles', cost: 3.50, color: 0x808080, reflectivity: 0.15 },
            { id: 'asphalt-brown', name: 'Brown Asphalt Shingles', cost: 3.50, color: 0x654321, reflectivity: 0.10 },
            { id: 'metal-white', name: 'White Metal Roof', cost: 8.00, color: 0xF5F5F5, reflectivity: 0.65 },
            { id: 'metal-black', name: 'Black Metal Roof', cost: 8.00, color: 0x1C1C1C, reflectivity: 0.05 },
            { id: 'metal-silver', name: 'Silver Metal Roof', cost: 8.00, color: 0xC0C0C0, reflectivity: 0.55 },
            { id: 'tile-terracotta', name: 'Terracotta Tiles', cost: 12.00, color: 0xE2725B, reflectivity: 0.25 },
            { id: 'tile-concrete', name: 'Concrete Tiles', cost: 10.00, color: 0x999999, reflectivity: 0.30 },
        ];

        // Simple icon components
        const HomeIcon = () => (
            <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
            </svg>
        );

        const ThermometerIcon = () => (
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
            </svg>
        );

        const WindIcon = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14 5l7 7m0 0l-7 7m7-7H3" />
            </svg>
        );

        const SunIcon = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
            </svg>
        );

        // Custom OrbitControls implementation
        class OrbitControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                
                this.target = new THREE.Vector3(0, 15, 0);
                this.minDistance = 20;
                this.maxDistance = 200;
                
                this.rotateSpeed = 0.5;
                this.zoomSpeed = 1.0;
                this.panSpeed = 0.5;
                
                this.spherical = new THREE.Spherical();
                this.sphericalDelta = new THREE.Spherical();
                
                this.panOffset = new THREE.Vector3();
                this.zoomChanged = false;
                
                this.state = 'none';
                this.rotateStart = new THREE.Vector2();
                this.rotateEnd = new THREE.Vector2();
                this.rotateDelta = new THREE.Vector2();
                
                this.panStart = new THREE.Vector2();
                this.panEnd = new THREE.Vector2();
                this.panDelta = new THREE.Vector2();
                
                this.scale = 1;
                
                this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this));
                this.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            onMouseDown(event) {
                event.preventDefault();
                
                if (event.button === 0) {
                    this.state = 'rotate';
                    this.rotateStart.set(event.clientX, event.clientY);
                } else if (event.button === 2) {
                    this.state = 'pan';
                    this.panStart.set(event.clientX, event.clientY);
                }
                
                this.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
            }
            
            onMouseMove(event) {
                event.preventDefault();
                
                if (this.state === 'rotate') {
                    this.rotateEnd.set(event.clientX, event.clientY);
                    this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);
                    
                    this.rotateLeft(2 * Math.PI * this.rotateDelta.x / this.domElement.clientHeight);
                    this.rotateUp(2 * Math.PI * this.rotateDelta.y / this.domElement.clientHeight);
                    
                    this.rotateStart.copy(this.rotateEnd);
                } else if (this.state === 'pan') {
                    this.panEnd.set(event.clientX, event.clientY);
                    this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed);
                    this.pan(this.panDelta.x, this.panDelta.y);
                    this.panStart.copy(this.panEnd);
                }
                
                this.update();
            }
            
            onMouseUp() {
                this.domElement.removeEventListener('mousemove', this.onMouseMove.bind(this));
                this.domElement.removeEventListener('mouseup', this.onMouseUp.bind(this));
                this.state = 'none';
            }
            
            onMouseWheel(event) {
                event.preventDefault();
                
                if (event.deltaY < 0) {
                    this.dollyIn(0.95);
                } else if (event.deltaY > 0) {
                    this.dollyOut(0.95);
                }
                
                this.update();
            }
            
            rotateLeft(angle) {
                this.sphericalDelta.theta -= angle;
            }
            
            rotateUp(angle) {
                this.sphericalDelta.phi -= angle;
            }
            
            pan(deltaX, deltaY) {
                const offset = new THREE.Vector3();
                const position = this.camera.position;
                offset.copy(position).sub(this.target);
                let targetDistance = offset.length();
                targetDistance *= Math.tan((this.camera.fov / 2) * Math.PI / 180.0);
                
                const panLeft = new THREE.Vector3();
                const v = new THREE.Vector3();
                v.setFromMatrixColumn(this.camera.matrix, 0);
                panLeft.copy(v).multiplyScalar(-2 * deltaX * targetDistance / this.domElement.clientHeight);
                
                const panUp = new THREE.Vector3();
                v.setFromMatrixColumn(this.camera.matrix, 1);
                panUp.copy(v).multiplyScalar(2 * deltaY * targetDistance / this.domElement.clientHeight);
                
                this.panOffset.add(panLeft).add(panUp);
            }
            
            dollyIn(dollyScale) {
                this.scale /= dollyScale;
            }
            
            dollyOut(dollyScale) {
                this.scale *= dollyScale;
            }
            
            update() {
                const offset = new THREE.Vector3();
                const position = this.camera.position;
                
                offset.copy(position).sub(this.target);
                this.spherical.setFromVector3(offset);
                
                this.spherical.theta += this.sphericalDelta.theta;
                this.spherical.phi += this.sphericalDelta.phi;
                
                this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));
                
                this.spherical.radius *= this.scale;
                this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));
                
                this.target.add(this.panOffset);
                
                offset.setFromSpherical(this.spherical);
                position.copy(this.target).add(offset);
                
                this.camera.lookAt(this.target);
                
                this.sphericalDelta.set(0, 0, 0);
                this.panOffset.set(0, 0, 0);
                this.scale = 1;
            }
        }

function HouseBuilder() {
            const [dimensions, setDimensions] = useState({ length: 40, width: 30 });
            const [selectedWall, setSelectedWall] = useState(null);
            const [wallInsulation, setWallInsulation] = useState({});
            const [wallExterior, setWallExterior] = useState({});
            const [roofMaterial, setRoofMaterial] = useState('asphalt-gray');
            const [viewMode, setViewMode] = useState('3d');
            const [selectionMode, setSelectionMode] = useState('exterior');
            const mountRef = useRef(null);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const controlsRef = useRef(null);
            const wallMeshesRef = useRef({});
            const roofMeshesRef = useRef([]);

            const WALL_HEIGHT = 9;
            // UPDATED: Tripled the pitch (was 1/8)
            const ROOF_PITCH = 3/8; 
            const floors = ['basement', 'first', 'second'];

            useEffect(() => {
                if (viewMode !== '3d' || !mountRef.current) return;

                // Scene setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb);
                sceneRef.current = scene;

                // Camera setup
                const camera = new THREE.PerspectiveCamera(60, 800 / 600, 0.1, 1000);
                camera.position.set(60, 40, 60);
                cameraRef.current = camera;

                // Renderer setup
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(800, 600);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // Controls
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.update();
                controlsRef.current = controls;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
                sunLight.position.set(50, 80, 50);
                sunLight.castShadow = true;
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                scene.add(sunLight);

                // Ground
                const groundGeometry = new THREE.PlaneGeometry(200, 200);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x3a7d3a, 
                    roughness: 0.8,
                    side: THREE.DoubleSide
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);

                // Grid helper
                const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x888888);
                scene.add(gridHelper);

                // Build house
                buildHouse();

                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    renderer.render(scene, camera);
                }
                animate();

                // Raycaster
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                function onMouseClick(event) {
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);
                    // Intersect with walls
                    const intersects = raycaster.intersectObjects(Object.values(wallMeshesRef.current));

                    if (intersects.length > 0) {
                        const clickedWall = intersects[0].object;
                        setSelectedWall(clickedWall.userData.wallId);
                    }
                }

                renderer.domElement.addEventListener('click', onMouseClick);

                return () => {
                    renderer.domElement.removeEventListener('click', onMouseClick);
                    mountRef.current?.removeChild(renderer.domElement);
                    renderer.dispose();
                };
            }, [viewMode]);

            useEffect(() => {
                if (viewMode === '3d') {
                    buildHouse();
                }
            }, [dimensions, wallInsulation, wallExterior, roofMaterial]); // Added dependencies

            const buildHouse = () => {
                if (!sceneRef.current) return;

                // Remove old house
                Object.values(wallMeshesRef.current).forEach(mesh => {
                    sceneRef.current.remove(mesh);
                });
                roofMeshesRef.current.forEach(mesh => {
                    sceneRef.current.remove(mesh);
                });
                wallMeshesRef.current = {};
                roofMeshesRef.current = [];

                const wallThickness = 0.5;
                
                // Build each floor
                floors.forEach((floor, floorIndex) => {
                    // UPDATED: Shift Y down by one wall height so Basement (index 0) is at -9
                    const floorY = (floorIndex - 1) * WALL_HEIGHT;

                    // Floor platform
                    const floorGeometry = new THREE.BoxGeometry(dimensions.length, 0.5, dimensions.width);
                    const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x8b7355 });
                    const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
                    floorMesh.position.set(0, floorY, 0);
                    floorMesh.castShadow = true;
                    floorMesh.receiveShadow = true;
                    sceneRef.current.add(floorMesh);

                    // --- Walls ---

                    // North wall
                    const northWallId = `${floor}-north`;
                    const northExterior = getWallExterior(northWallId);
                    const northGeometry = new THREE.BoxGeometry(dimensions.length, WALL_HEIGHT, wallThickness);
                    const northMaterial = new THREE.MeshStandardMaterial({ color: northExterior.color });
                    const northWall = new THREE.Mesh(northGeometry, northMaterial);
                    northWall.position.set(0, floorY + WALL_HEIGHT / 2, -dimensions.width / 2);
                    northWall.castShadow = true;
                    northWall.receiveShadow = true;
                    northWall.userData.wallId = northWallId;
                    sceneRef.current.add(northWall);
                    wallMeshesRef.current[northWallId] = northWall;

                    // South wall
                    const southWallId = `${floor}-south`;
                    const southExterior = getWallExterior(southWallId);
                    const southGeometry = new THREE.BoxGeometry(dimensions.length, WALL_HEIGHT, wallThickness);
                    const southMaterial = new THREE.MeshStandardMaterial({ color: southExterior.color });
                    const southWall = new THREE.Mesh(southGeometry, southMaterial);
                    southWall.position.set(0, floorY + WALL_HEIGHT / 2, dimensions.width / 2);
                    southWall.castShadow = true;
                    southWall.receiveShadow = true;
                    southWall.userData.wallId = southWallId;
                    sceneRef.current.add(southWall);
                    wallMeshesRef.current[southWallId] = southWall;

                    // East wall
                    const eastWallId = `${floor}-east`;
                    const eastExterior = getWallExterior(eastWallId);
                    const eastGeometry = new THREE.BoxGeometry(wallThickness, WALL_HEIGHT, dimensions.width);
                    const eastMaterial = new THREE.MeshStandardMaterial({ color: eastExterior.color });
                    const eastWall = new THREE.Mesh(eastGeometry, eastMaterial);
                    eastWall.position.set(dimensions.length / 2, floorY + WALL_HEIGHT / 2, 0);
                    eastWall.castShadow = true;
                    eastWall.receiveShadow = true;
                    eastWall.userData.wallId = eastWallId;
                    sceneRef.current.add(eastWall);
                    wallMeshesRef.current[eastWallId] = eastWall;

                    // West wall
                    const westWallId = `${floor}-west`;
                    const westExterior = getWallExterior(westWallId);
                    const westGeometry = new THREE.BoxGeometry(wallThickness, WALL_HEIGHT, dimensions.width);
                    const westMaterial = new THREE.MeshStandardMaterial({ color: westExterior.color });
                    const westWall = new THREE.Mesh(westGeometry, westMaterial);
                    westWall.position.set(-dimensions.length / 2, floorY + WALL_HEIGHT / 2, 0);
                    westWall.castShadow = true;
                    westWall.receiveShadow = true;
                    westWall.userData.wallId = westWallId;
                    sceneRef.current.add(westWall);
                    wallMeshesRef.current[westWallId] = westWall;

                    // ADDED: Demarcation Line (Trim) between stories
                    // We place a slightly wider, thin white box at the top of the wall
                    const trimHeight = 0.4;
                    const trimGeometry = new THREE.BoxGeometry(dimensions.length + 0.8, trimHeight, dimensions.width + 0.8);
                    const trimMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF }); // White trim
                    const trimMesh = new THREE.Mesh(trimGeometry, trimMaterial);
                    trimMesh.position.set(0, floorY + WALL_HEIGHT, 0);
                    trimMesh.castShadow = true;
                    trimMesh.receiveShadow = true;
                    sceneRef.current.add(trimMesh);
                    roofMeshesRef.current.push(trimMesh); // Track it here to delete on rebuild
                });

                // Build proper gable roof
                // UPDATED: Roof sits on top of the stack. Since we shifted everything down by 1 wall height,
                // the top of the 2nd floor is at: (2 - 1) * 9 + 9 = 18. 
                // Alternatively: (floors.length - 1) * WALL_HEIGHT
                const roofY = (floors.length - 1) * WALL_HEIGHT; 
                
                const roofRise = (dimensions.width / 2) * ROOF_PITCH;
                const roofMat = ROOF_MATERIALS.find(m => m.id === roofMaterial);
                const roofColor = roofMat ? roofMat.color : 0x808080;
                
                // Gable Shape
                const gableShape = new THREE.Shape();
                gableShape.moveTo(-dimensions.width / 2, 0);
                gableShape.lineTo(dimensions.width / 2, 0);
                gableShape.lineTo(0, roofRise);
                gableShape.lineTo(-dimensions.width / 2, 0);
                
                const gableGeometry = new THREE.ShapeGeometry(gableShape);
                const gableMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xE8E8E8,
                    side: THREE.DoubleSide 
                });
                
                // West gable
                const westGable = new THREE.Mesh(gableGeometry, gableMaterial);
                westGable.position.set(-dimensions.length / 2, roofY, 0);
                westGable.rotation.y = Math.PI / 2;
                westGable.castShadow = true;
                westGable.receiveShadow = true;
                sceneRef.current.add(westGable);
                roofMeshesRef.current.push(westGable);
                
                // East gable
                const eastGable = new THREE.Mesh(gableGeometry, gableMaterial);
                eastGable.position.set(dimensions.length / 2, roofY, 0);
                eastGable.rotation.y = -Math.PI / 2;
                eastGable.castShadow = true;
                eastGable.receiveShadow = true;
                sceneRef.current.add(eastGable);
                roofMeshesRef.current.push(eastGable);

                // Roof Planes
                const roofSlantLength = Math.sqrt(Math.pow(dimensions.width / 2, 2) + Math.pow(roofRise, 2));
                const roofAngle = Math.atan2(roofRise, dimensions.width / 2);
                
                const roofMaterialMesh = new THREE.MeshStandardMaterial({ 
                    color: roofColor,
                    side: THREE.DoubleSide,
                    roughness: 0.9
                });
                
                // North roof
                const northRoofGeom = new THREE.PlaneGeometry(dimensions.length + 1, roofSlantLength); // +1 for overhang
                const northRoof = new THREE.Mesh(northRoofGeom, roofMaterialMesh);
                // Pitch UP towards center (minus angle)
                northRoof.position.set(0, roofY + roofRise / 2, -dimensions.width / 4);
                northRoof.rotation.x = -Math.PI / 2 - roofAngle; 
                northRoof.castShadow = true;
                northRoof.receiveShadow = true;
                sceneRef.current.add(northRoof);
                roofMeshesRef.current.push(northRoof);

                // South roof
                const southRoofGeom = new THREE.PlaneGeometry(dimensions.length + 1, roofSlantLength);
                const southRoof = new THREE.Mesh(southRoofGeom, roofMaterialMesh.clone());
                // Pitch UP towards center (plus angle)
                southRoof.position.set(0, roofY + roofRise / 2, dimensions.width / 4);
                southRoof.rotation.x = -Math.PI / 2 + roofAngle;
                southRoof.castShadow = true;
                southRoof.receiveShadow = true;
                sceneRef.current.add(southRoof);
                roofMeshesRef.current.push(southRoof);
            };

            const getWallData = () => {
                const walls = [];
                floors.forEach(floor => {
                    walls.push({ id: `${floor}-north`, floor, orientation: 'north', length: dimensions.length, height: WALL_HEIGHT, area: dimensions.length * WALL_HEIGHT });
                    walls.push({ id: `${floor}-south`, floor, orientation: 'south', length: dimensions.length, height: WALL_HEIGHT, area: dimensions.length * WALL_HEIGHT });
                    walls.push({ id: `${floor}-east`, floor, orientation: 'east', length: dimensions.width, height: WALL_HEIGHT, area: dimensions.width * WALL_HEIGHT });
                    walls.push({ id: `${floor}-west`, floor, orientation: 'west', length: dimensions.width, height: WALL_HEIGHT, area: dimensions.width * WALL_HEIGHT });
                });
                return walls;
            };

            const walls = getWallData();

            const handleMaterialSelect = (materialId) => {
                if (selectionMode === 'exterior' && selectedWall) {
                    setWallExterior(prev => ({ ...prev, [selectedWall]: materialId }));
                } else if (selectionMode === 'insulation' && selectedWall) {
                    setWallInsulation(prev => ({ ...prev, [selectedWall]: materialId }));
                }
            };

            const getWallExterior = (wallId) => {
                const exteriorId = wallExterior[wallId] || 'brick-red';
                return EXTERIOR_MATERIALS.find(mat => mat.id === exteriorId) || EXTERIOR_MATERIALS[0];
            };

            const getWallInsulation = (wallId) => {
                const insulationId = wallInsulation[wallId] || 'none';
                return INSULATION_OPTIONS.find(opt => opt.id === insulationId);
            };

            const getTotals = () => {
                let totalCost = 0;
                let totalArea = 0;
                let weightedRValue = 0;

                walls.forEach(wall => {
                    const insulation = getWallInsulation(wall.id);
                    totalCost += insulation.cost * wall.area;
                    totalArea += wall.area;
                    weightedRValue += insulation.rValue * wall.area;
                });

                return {
                    totalCost: totalCost.toFixed(2),
                    totalArea: totalArea.toFixed(0),
                    averageRValue: totalArea > 0 ? (weightedRValue / totalArea).toFixed(1) : 0
                };
            };

            const totals = getTotals();

            // ... (Render Floor Plan Logic remains the same, omitted for brevity but required if you didn't paste the full helper functions above)
            const renderFloorPlan = () => {
               // ... existing floor plan code ...
               // Simplest to just return a placeholder if you don't need it changed, 
               // but typically in React singular component replacements, you need the whole function.
               // Assuming the previous renderFloorPlan logic is still valid.
               
               const scale = 5;
               return (
                    <svg width="800" height="600" className="border border-gray-300 bg-white">
                        {floors.map((floor, floorIndex) => (
                            <g key={floor} transform={`translate(50, ${50 + floorIndex * 220})`}>
                                <text x={0} y={-10} fontSize="16" fontWeight="bold" className="uppercase">{floor} Floor</text>
                                <rect x={0} y={0} width={dimensions.length * scale} height={20} fill={`#${getWallInsulation(`${floor}-north`).color.toString(16).padStart(6, '0')}`} stroke="#1f2937" strokeWidth="2" className="cursor-pointer hover:opacity-80" onClick={() => setSelectedWall(`${floor}-north`)} />
                                <text x={dimensions.length * scale / 2} y={12} textAnchor="middle" fontSize="10" fill="#1f2937">N</text>
                                <rect x={0} y={dimensions.width * scale - 20} width={dimensions.length * scale} height={20} fill={`#${getWallInsulation(`${floor}-south`).color.toString(16).padStart(6, '0')}`} stroke="#1f2937" strokeWidth="2" className="cursor-pointer hover:opacity-80" onClick={() => setSelectedWall(`${floor}-south`)} />
                                <text x={dimensions.length * scale / 2} y={dimensions.width * scale - 8} textAnchor="middle" fontSize="10" fill="#1f2937">S</text>
                                <rect x={0} y={20} width={20} height={dimensions.width * scale - 40} fill={`#${getWallInsulation(`${floor}-west`).color.toString(16).padStart(6, '0')}`} stroke="#1f2937" strokeWidth="2" className="cursor-pointer hover:opacity-80" onClick={() => setSelectedWall(`${floor}-west`)} />
                                <text x={10} y={dimensions.width * scale / 2} textAnchor="middle" fontSize="10" fill="#1f2937">W</text>
                                <rect x={dimensions.length * scale - 20} y={20} width={20} height={dimensions.width * scale - 40} fill={`#${getWallInsulation(`${floor}-east`).color.toString(16).padStart(6, '0')}`} stroke="#1f2937" strokeWidth="2" className="cursor-pointer hover:opacity-80" onClick={() => setSelectedWall(`${floor}-east`)} />
                                <text x={dimensions.length * scale - 10} y={dimensions.width * scale / 2} textAnchor="middle" fontSize="10" fill="#1f2937">E</text>
                                <rect x={20} y={20} width={dimensions.length * scale - 40} height={dimensions.width * scale - 40} fill="#f3f4f6" stroke="none" />
                                <text x={dimensions.length * scale / 2} y={dimensions.width * scale + 20} textAnchor="middle" fontSize="12">{dimensions.length}' × {dimensions.width}'</text>
                            </g>
                        ))}
                    </svg>
                );
            };

            // Return JSX (Same as before)
            return (
                <div className="min-h-screen bg-gray-50 p-8">
                    <div className="max-w-7xl mx-auto">
                        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                            <div className="flex items-center gap-3 mb-6">
                                <div className="text-blue-600"><HomeIcon /></div>
                                <h1 className="text-3xl font-bold text-gray-900">Multi-Story House Builder</h1>
                            </div>

                            <div className="grid grid-cols-2 gap-4 mb-6">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">Length (feet)</label>
                                    <input type="number" value={dimensions.length} onChange={(e) => setDimensions(prev => ({ ...prev, length: parseInt(e.target.value) || 0 }))} className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" min="10" max="100" />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">Width (feet)</label>
                                    <input type="number" value={dimensions.width} onChange={(e) => setDimensions(prev => ({ ...prev, width: parseInt(e.target.value) || 0 }))} className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" min="10" max="100" />
                                </div>
                            </div>

                            <div className="flex gap-2 mb-6">
                                <button onClick={() => setViewMode('3d')} className={`px-4 py-2 rounded-lg font-medium transition-colors ${viewMode === '3d' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>3D View</button>
                                <button onClick={() => setViewMode('floor')} className={`px-4 py-2 rounded-lg font-medium transition-colors ${viewMode === 'floor' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>Floor Plan View</button>
                            </div>

                            <div className="mb-6 flex justify-center">
                                {viewMode === '3d' ? (
                                    <div>
                                        <div ref={mountRef} className="border-4 border-gray-300 rounded-lg"></div>
                                        <p className="text-sm text-gray-600 mt-2 text-center">Left-click + drag to rotate • Right-click + drag to pan • Scroll to zoom • Click walls to select</p>
                                    </div>
                                ) : (
                                    renderFloorPlan()
                                )}
                            </div>

                            {selectedWall && (
                                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                                    <h3 className="font-semibold text-blue-900 mb-2">Selected: {selectedWall.replace('-', ' ').toUpperCase()}</h3>
                                    <div className="text-sm text-blue-700">Exterior: {getWallExterior(selectedWall).name}</div>
                                    <div className="text-sm text-blue-700">Insulation: {getWallInsulation(selectedWall).name} (R-{getWallInsulation(selectedWall).rValue})</div>
                                </div>
                            )}

                            <div className="flex gap-2 mb-6">
                                <button onClick={() => setSelectionMode('exterior')} className={`flex-1 px-4 py-2 rounded-lg font-medium transition-colors ${selectionMode === 'exterior' ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>Wall Exterior</button>
                                <button onClick={() => setSelectionMode('insulation')} className={`flex-1 px-4 py-2 rounded-lg font-medium transition-colors ${selectionMode === 'insulation' ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>Wall Insulation</button>
                            </div>

                            {selectionMode === 'exterior' && (
                                <div className="mb-6">
                                    <h3 className="text-lg font-semibold text-gray-900 mb-3">Select Wall Exterior Material</h3>
                                    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3">
                                        {EXTERIOR_MATERIALS.map(material => (
                                            <button key={material.id} onClick={() => handleMaterialSelect(material.id)} disabled={!selectedWall} className={`p-4 rounded-lg border-2 transition-all ${selectedWall && wallExterior[selectedWall] === material.id ? 'border-green-600 bg-green-50' : 'border-gray-300 hover:border-green-400'} ${!selectedWall ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}>
                                                <div className="w-full h-12 rounded mb-2 border border-gray-300" style={{ backgroundColor: `#${material.color.toString(16).padStart(6, '0')}` }}></div>
                                                <div className="text-xs font-medium text-gray-900">{material.name}</div>
                                                <div className="text-xs text-gray-600">${material.cost}/sq ft</div>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {selectionMode === 'insulation' && (
                                <div className="mb-6">
                                    <h3 className="text-lg font-semibold text-gray-900 mb-3">Select Insulation Type</h3>
                                    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                                        {INSULATION_OPTIONS.map(option => (
                                            <button key={option.id} onClick={() => handleMaterialSelect(option.id)} disabled={!selectedWall} className={`p-4 rounded-lg border-2 transition-all ${selectedWall && wallInsulation[selectedWall] === option.id ? 'border-blue-600 bg-blue-50' : 'border-gray-300 hover:border-blue-400'} ${!selectedWall ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}>
                                                <div className="w-full h-8 rounded mb-2" style={{ backgroundColor: `#${option.color.toString(16).padStart(6, '0')}` }}></div>
                                                <div className="text-sm font-medium text-gray-900">{option.name}</div>
                                                <div className="text-xs text-gray-600">R-Value: {option.rValue}</div>
                                                <div className="text-xs text-gray-600">${option.cost}/sq ft</div>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            )}

                            <div className="mb-6">
                                <h3 className="text-lg font-semibold text-gray-900 mb-3">Roof Material</h3>
                                <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-4 gap-3">
                                    {ROOF_MATERIALS.map(material => (
                                        <button key={material.id} onClick={() => setRoofMaterial(material.id)} className={`p-4 rounded-lg border-2 transition-all ${roofMaterial === material.id ? 'border-purple-600 bg-purple-50' : 'border-gray-300 hover:border-purple-400'} cursor-pointer`}>
                                            <div className="w-full h-12 rounded mb-2 border border-gray-300" style={{ backgroundColor: `#${material.color.toString(16).padStart(6, '0')}` }}></div>
                                            <div className="text-xs font-medium text-gray-900">{material.name}</div>
                                            <div className="text-xs text-gray-600">${material.cost}/sq ft</div>
                                            <div className="text-xs text-gray-600">Reflect: {(material.reflectivity * 100).toFixed(0)}%</div>
                                        </button>
                                    ))}
                                </div>
                            </div>

                            <div className="grid grid-cols-3 gap-4">
                                <div className="bg-gray-100 rounded-lg p-4">
                                    <div className="text-sm text-gray-600 mb-1">Total Wall Area</div>
                                    <div className="text-2xl font-bold text-gray-900">{totals.totalArea} sq ft</div>
                                </div>
                                <div className="bg-gray-100 rounded-lg p-4">
                                    <div className="text-sm text-gray-600 mb-1">Average R-Value</div>
                                    <div className="text-2xl font-bold text-gray-900">R-{totals.averageRValue}</div>
                                </div>
                                <div className="bg-gray-100 rounded-lg p-4">
                                    <div className="text-sm text-gray-600 mb-1">Total Insulation Cost</div>
                                    <div className="text-2xl font-bold text-gray-900">${totals.totalCost}</div>
                                </div>
                            </div>

                            <div className="mt-6 p-4 bg-green-50 border border-green-200 rounded-lg">
                                <h3 className="font-semibold text-green-900 mb-2 flex items-center gap-2">
                                    <ThermometerIcon />
                                    Future HVAC Calculations
                                </h3>
                                <div className="text-sm text-green-700 space-y-1">
                                    <div className="flex items-center gap-2"><SunIcon /><span>Solar heat gain through walls and windows</span></div>
                                    <div className="flex items-center gap-2"><WindIcon /><span>Wind load and infiltration calculations</span></div>
                                    <div className="flex items-center gap-2"><ThermometerIcon /><span>Night radiation and thermal mass effects</span></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }


        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<HouseBuilder />);
    </script>
</body>
</html>


