<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Story House Builder</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">

const { useState, useEffect, useRef } = React;

// --- CONSTANTS ---
const INSULATION_OPTIONS = [
    { id: 'none', name: 'No Insulation', rValue: 2, color: 0xe5e7eb },
    { id: 'fiberglass-r13', name: 'Fiberglass Batt R-13', rValue: 13, color: 0xfbbf24 },
    { id: 'fiberglass-r19', name: 'Fiberglass Batt R-19', rValue: 19, color: 0xf59e0b },
    { id: 'fiberglass-r21', name: 'Fiberglass Batt R-21', rValue: 21, color: 0xd97706 },
    { id: 'spray-foam-r25', name: 'Spray Foam R-25', rValue: 25, color: 0x10b981 },
    { id: 'spray-foam-r30', name: 'Spray Foam R-30', rValue: 30, color: 0x059669 },
    { id: 'rigid-foam-r20', name: 'Rigid Foam R-20', rValue: 20, color: 0x3b82f6 },
];

const EXTERIOR_MATERIALS = [
    { id: 'brick-red', name: 'Red Brick', color: 0x8B4513 },
    { id: 'brick-tan', name: 'Tan Brick', color: 0xD2B48C },
    { id: 'vinyl-white', name: 'White Vinyl Siding', color: 0xF5F5F5 },
    { id: 'vinyl-gray', name: 'Gray Vinyl Siding', color: 0x808080 },
    { id: 'vinyl-beige', name: 'Beige Vinyl Siding', color: 0xF5F5DC },
    { id: 'clapboard-white', name: 'White Clapboard', color: 0xFAFAFA },
    { id: 'clapboard-blue', name: 'Blue Clapboard', color: 0x4682B4 },
    { id: 'stucco-white', name: 'White Stucco', color: 0xFFFFF0 },
    { id: 'stucco-tan', name: 'Tan Stucco', color: 0xD2B48C },
    { id: 'stone-gray', name: 'Gray Stone', color: 0x708090 },
];

const ROOF_MATERIALS = [
    { id: 'asphalt-black', name: 'Black Asphalt Shingles', color: 0x2F2F2F, reflectivity: 0.05 },
    { id: 'asphalt-gray', name: 'Gray Asphalt Shingles', color: 0x808080, reflectivity: 0.15 },
    { id: 'asphalt-brown', name: 'Brown Asphalt Shingles', color: 0x654321, reflectivity: 0.10 },
    { id: 'metal-white', name: 'White Metal Roof', color: 0xF5F5F5, reflectivity: 0.65 },
    { id: 'metal-black', name: 'Black Metal Roof', color: 0x1C1C1C, reflectivity: 0.05 },
    { id: 'metal-silver', name: 'Silver Metal Roof', color: 0xC0C0C0, reflectivity: 0.55 },
    { id: 'tile-terracotta', name: 'Terracotta Tiles', color: 0xE2725B, reflectivity: 0.25 },
    { id: 'tile-concrete', name: 'Concrete Tiles', color: 0x999999, reflectivity: 0.30 },
];

// Feature Stats (New)
const FEATURE_STATS = {
    'window-std': { name: 'Std Window', rValue: 3, width: 3, height: 4, color: 0x87ceeb },
    'window-pic': { name: 'Picture Window', rValue: 3, width: 6, height: 5, color: 0x87ceeb },
    'door': { name: 'Door', rValue: 5, width: 3, height: 7, color: 0x8b4513 }
};

// Icons
const HomeIcon = () => (<svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" /></svg>);
const ThermometerIcon = () => (<svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" /></svg>);
const FireIcon = () => (<svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.879 16.121A3 3 0 1012.015 11L11 14H9c0 .768.293 1.536.879 2.121z" /></svg>);
const TrashIcon = () => (<svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>);

// OrbitControls
class OrbitControls {
    constructor(camera, domElement) {
        this.camera = camera;
        this.domElement = domElement;
        this.target = new THREE.Vector3(0, 15, 0);
        this.minDistance = 20;
        this.maxDistance = 200;
        this.rotateSpeed = 0.5;
        this.scale = 1;
        this.spherical = new THREE.Spherical();
        this.sphericalDelta = new THREE.Spherical();
        this.panOffset = new THREE.Vector3();
        this.state = 'none';
        this.rotateStart = new THREE.Vector2();
        this.rotateEnd = new THREE.Vector2();
        this.rotateDelta = new THREE.Vector2();
        this.panStart = new THREE.Vector2();
        this.panEnd = new THREE.Vector2();
        this.panDelta = new THREE.Vector2();

        this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
        this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this));
        this.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
    }
    
    onMouseDown(event) {
        event.preventDefault();
        if (event.button === 0) {
            this.state = 'rotate';
            this.rotateStart.set(event.clientX, event.clientY);
        } else if (event.button === 2) {
            this.state = 'pan';
            this.panStart.set(event.clientX, event.clientY);
        }
        this.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
        this.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
    }
    
    onMouseMove(event) {
        event.preventDefault();
        if (this.state === 'rotate') {
            this.rotateEnd.set(event.clientX, event.clientY);
            this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);
            this.rotateLeft(2 * Math.PI * this.rotateDelta.x / this.domElement.clientHeight);
            this.rotateUp(2 * Math.PI * this.rotateDelta.y / this.domElement.clientHeight);
            this.rotateStart.copy(this.rotateEnd);
        } else if (this.state === 'pan') {
            this.panEnd.set(event.clientX, event.clientY);
            this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(0.5);
            this.pan(this.panDelta.x, this.panDelta.y);
            this.panStart.copy(this.panEnd);
        }
        this.update();
    }
    
    onMouseUp() {
        this.domElement.removeEventListener('mousemove', this.onMouseMove.bind(this));
        this.domElement.removeEventListener('mouseup', this.onMouseUp.bind(this));
        this.state = 'none';
    }
    
    onMouseWheel(event) {
        event.preventDefault();
        if (event.deltaY < 0) this.scale /= 0.95; else this.scale *= 0.95;
        this.update();
    }
    
    rotateLeft(angle) { this.sphericalDelta.theta -= angle; }
    rotateUp(angle) { this.sphericalDelta.phi -= angle; }
    
    pan(deltaX, deltaY) {
        const offset = new THREE.Vector3().copy(this.camera.position).sub(this.target);
        let targetDistance = offset.length() * Math.tan((this.camera.fov / 2) * Math.PI / 180.0);
        const v = new THREE.Vector3();
        const panLeft = new THREE.Vector3().setFromMatrixColumn(this.camera.matrix, 0).multiplyScalar(-2 * deltaX * targetDistance / this.domElement.clientHeight);
        const panUp = new THREE.Vector3().setFromMatrixColumn(this.camera.matrix, 1).multiplyScalar(2 * deltaY * targetDistance / this.domElement.clientHeight);
        this.panOffset.add(panLeft).add(panUp);
    }
    
    update() {
        const offset = new THREE.Vector3().copy(this.camera.position).sub(this.target);
        this.spherical.setFromVector3(offset);
        this.spherical.theta += this.sphericalDelta.theta;
        this.spherical.phi += this.sphericalDelta.phi;
        this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));
        this.spherical.radius *= this.scale;
        this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));
        this.target.add(this.panOffset);
        offset.setFromSpherical(this.spherical);
        this.camera.position.copy(this.target).add(offset);
        this.camera.lookAt(this.target);
        this.sphericalDelta.set(0, 0, 0);
        this.panOffset.set(0, 0, 0);
        this.scale = 1;
    }
}

function HouseBuilder() {
    const [dimensions, setDimensions] = useState({ length: 40, width: 30 });
    const [selectedWall, setSelectedWall] = useState(null);
    const [wallInsulation, setWallInsulation] = useState({});
    const [wallExterior, setWallExterior] = useState({});
    const [roofMaterial, setRoofMaterial] = useState('asphalt-gray');
    const [viewMode, setViewMode] = useState('3d');
    const [selectionMode, setSelectionMode] = useState('exterior');
    // New: Wall Features state
    const [wallFeatures, setWallFeatures] = useState({});
    
    // Environmental State
    const [outsideTemp, setOutsideTemp] = useState(32);
    const [groundTemp, setGroundTemp] = useState(50);
    const [insideTemp, setInsideTemp] = useState(70);
    const [windSpeed, setWindSpeed] = useState(10);
    const [windDirection, setWindDirection] = useState('north');

    const mountRef = useRef(null);
    const sceneRef = useRef(null);
    const cameraRef = useRef(null);
    const rendererRef = useRef(null);
    const controlsRef = useRef(null);
    const wallMeshesRef = useRef({});
    const roofMeshesRef = useRef([]);

    const WALL_HEIGHT = 9;
    const ROOF_PITCH = 3/8;
    const floors = ['basement', 'first', 'second'];

    useEffect(() => {
        if (viewMode !== '3d' || !mountRef.current) return;

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        sceneRef.current = scene;

        // Camera setup
        const camera = new THREE.PerspectiveCamera(60, 800 / 600, 0.1, 1000);
        camera.position.set(60, 40, 60);
        cameraRef.current = camera;

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(800, 600);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        mountRef.current.appendChild(renderer.domElement);
        rendererRef.current = renderer;

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.update();
        controlsRef.current = controls;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(50, 80, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // Ground - MODIFIED FOR PHANTOM VIEW
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3a7d3a, 
            roughness: 0.8,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.4 // Semi-transparent
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Grid helper
        const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x888888);
        gridHelper.material.transparent = true;
        gridHelper.material.opacity = 0.3;
        scene.add(gridHelper);

        // Build house
        buildHouse();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Raycaster
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Object.values(wallMeshesRef.current));

            if (intersects.length > 0) {
                // Ensure we get the wall ID even if we click a child element
                let target = intersects[0].object;
                while (target.parent && !target.userData.wallId) {
                    target = target.parent;
                }
                if (target.userData.wallId) {
                    setSelectedWall(target.userData.wallId);
                }
            }
        }

        renderer.domElement.addEventListener('click', onMouseClick);

        return () => {
            renderer.domElement.removeEventListener('click', onMouseClick);
            mountRef.current?.removeChild(renderer.domElement);
            renderer.dispose();
        };
    }, [viewMode]);

    useEffect(() => {
        if (viewMode === '3d') {
            buildHouse();
        }
    }, [dimensions, wallInsulation, wallExterior, roofMaterial, wallFeatures]);

    const buildHouse = () => {
        if (!sceneRef.current) return;

        // Cleanup: Remove old meshes
        Object.values(wallMeshesRef.current).forEach(mesh => sceneRef.current.remove(mesh));
        // Clear children but keep ground and lights (simple way: filter by type)
        // Actually safer to track meshes in refs as we were doing
        roofMeshesRef.current.forEach(mesh => sceneRef.current.remove(mesh));
        // Clear window stickers if they were added to scene directly
        sceneRef.current.children = sceneRef.current.children.filter(c => 
            c.type !== 'Mesh' || 
            (c.geometry.type === 'PlaneGeometry' && c.rotation.x === -Math.PI/2) || // Ground
            c.geometry.type === 'BoxGeometry' && c.scale.y === 0.5 // Keep floor plates if not tracked
        );

        wallMeshesRef.current = {};
        roofMeshesRef.current = [];

        const wallThickness = 0.5;
        
        // Build each floor
        floors.forEach((floor, floorIndex) => {
            const floorY = (floorIndex - 1) * WALL_HEIGHT;
            const isBasement = floor === 'basement';

            // Floor platform
            const floorGeometry = new THREE.BoxGeometry(dimensions.length, 0.5, dimensions.width);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x8b7355 });
            const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
            floorMesh.position.set(0, floorY, 0);
            floorMesh.castShadow = true;
            floorMesh.receiveShadow = true;
            sceneRef.current.add(floorMesh);
            roofMeshesRef.current.push(floorMesh); // Track for cleanup

            // Walls
            const directions = [
                { id: 'north', pos: [0, floorY + WALL_HEIGHT / 2, -dimensions.width / 2], dim: [dimensions.length, WALL_HEIGHT, wallThickness] },
                { id: 'south', pos: [0, floorY + WALL_HEIGHT / 2, dimensions.width / 2], dim: [dimensions.length, WALL_HEIGHT, wallThickness] },
                { id: 'east', pos: [dimensions.length / 2, floorY + WALL_HEIGHT / 2, 0], dim: [wallThickness, WALL_HEIGHT, dimensions.width] },
                { id: 'west', pos: [-dimensions.length / 2, floorY + WALL_HEIGHT / 2, 0], dim: [wallThickness, WALL_HEIGHT, dimensions.width] },
            ];

            directions.forEach(dir => {
                const wallId = `${floor}-${dir.id}`;
                const exterior = getWallExterior(wallId);
                
                // PHANTOM BASEMENT MATERIAL LOGIC
                let material;
                if (isBasement) {
                    material = new THREE.MeshPhysicalMaterial({
                        color: 0x708090, 
                        transparent: true,
                        opacity: 0.7,
                        roughness: 0.5,
                        metalness: 0.1
                    });
                } else {
                    material = new THREE.MeshStandardMaterial({ color: exterior.color });
                }

                const mesh = new THREE.Mesh(new THREE.BoxGeometry(...dir.dim), material);
                mesh.position.set(...dir.pos);
                mesh.castShadow = !isBasement;
                mesh.receiveShadow = true;
                mesh.userData.wallId = wallId;
                sceneRef.current.add(mesh);
                wallMeshesRef.current[wallId] = mesh;

                // --- STICKER LOGIC ---
                const features = wallFeatures[wallId] || [];
                const wallWidth = dir.id === 'north' || dir.id === 'south' ? dimensions.length : dimensions.width;
                const spacing = wallWidth / (features.length + 1);

                features.forEach((feature, idx) => {
                    const stats = FEATURE_STATS[feature.type];
                    // Sticker dimensions: slightly thicker than wall to protrude
                    const featureGeom = new THREE.BoxGeometry(
                        dir.id === 'north' || dir.id === 'south' ? stats.width : wallThickness + 0.2, 
                        stats.height, 
                        dir.id === 'north' || dir.id === 'south' ? wallThickness + 0.2 : stats.width
                    );
                    
                    const featureMat = new THREE.MeshStandardMaterial({ 
                        color: stats.color,
                        roughness: 0.2,
                        metalness: 0.8 
                    });
                    
                    const featureMesh = new THREE.Mesh(featureGeom, featureMat);
                    
                    // Positioning relative to wall center
                    const offset = -wallWidth/2 + (spacing * (idx + 1));
                    let fx = 0, fz = 0;
                    const yOffset = feature.type.includes('door') ? (-WALL_HEIGHT/2 + stats.height/2) : 0; 

                    if (dir.id === 'north') { fx = offset; fz = 0; }
                    if (dir.id === 'south') { fx = -offset; fz = 0; } 
                    if (dir.id === 'east')  { fx = 0; fz = -offset; }
                    if (dir.id === 'west')  { fx = 0; fz = offset; }

                    featureMesh.position.set(
                        mesh.position.x + fx, 
                        mesh.position.y + yOffset, 
                        mesh.position.z + fz
                    );
                    
                    sceneRef.current.add(featureMesh);
                    roofMeshesRef.current.push(featureMesh); // Track for cleanup
                });
            });

            // Demarcation Line
            const trimHeight = 0.4;
            const trimGeometry = new THREE.BoxGeometry(dimensions.length + 0.8, trimHeight, dimensions.width + 0.8);
            const trimMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const trimMesh = new THREE.Mesh(trimGeometry, trimMaterial);
            trimMesh.position.set(0, floorY + WALL_HEIGHT, 0);
            sceneRef.current.add(trimMesh);
            roofMeshesRef.current.push(trimMesh);
        });

        // Roof
        const roofY = (floors.length - 1) * WALL_HEIGHT; 
        const roofRise = (dimensions.width / 2) * ROOF_PITCH;
        const roofMat = ROOF_MATERIALS.find(m => m.id === roofMaterial);
        const roofColor = roofMat ? roofMat.color : 0x808080;
        
        // Gables
        const gableShape = new THREE.Shape();
        gableShape.moveTo(-dimensions.width / 2, 0);
        gableShape.lineTo(dimensions.width / 2, 0);
        gableShape.lineTo(0, roofRise);
        gableShape.lineTo(-dimensions.width / 2, 0);
        const gableGeometry = new THREE.ShapeGeometry(gableShape);
        const gableMaterial = new THREE.MeshStandardMaterial({ color: 0xE8E8E8, side: THREE.DoubleSide });
        
        const westGable = new THREE.Mesh(gableGeometry, gableMaterial);
        westGable.position.set(-dimensions.length / 2, roofY, 0);
        westGable.rotation.y = Math.PI / 2;
        sceneRef.current.add(westGable);
        roofMeshesRef.current.push(westGable);
        
        const eastGable = new THREE.Mesh(gableGeometry, gableMaterial);
        eastGable.position.set(dimensions.length / 2, roofY, 0);
        eastGable.rotation.y = -Math.PI / 2;
        sceneRef.current.add(eastGable);
        roofMeshesRef.current.push(eastGable);

        // Slopes
        const roofSlantLength = Math.sqrt(Math.pow(dimensions.width / 2, 2) + Math.pow(roofRise, 2));
        const roofAngle = Math.atan2(roofRise, dimensions.width / 2);
        const roofMaterialMesh = new THREE.MeshStandardMaterial({ color: roofColor, side: THREE.DoubleSide, roughness: 0.9 });
        
        const northRoof = new THREE.Mesh(new THREE.PlaneGeometry(dimensions.length + 1, roofSlantLength), roofMaterialMesh);
        northRoof.position.set(0, roofY + roofRise / 2, -dimensions.width / 4);
        northRoof.rotation.x = -Math.PI / 2 - roofAngle; 
        sceneRef.current.add(northRoof);
        roofMeshesRef.current.push(northRoof);

        const southRoof = new THREE.Mesh(new THREE.PlaneGeometry(dimensions.length + 1, roofSlantLength), roofMaterialMesh.clone());
        southRoof.position.set(0, roofY + roofRise / 2, dimensions.width / 4);
        southRoof.rotation.x = -Math.PI / 2 + roofAngle;
        sceneRef.current.add(southRoof);
        roofMeshesRef.current.push(southRoof);
    };

    const getWallData = () => {
        const walls = [];
        floors.forEach(floor => {
            const directions = ['north', 'south', 'east', 'west'];
            directions.forEach(dir => {
                const isLong = dir === 'north' || dir === 'south';
                walls.push({
                    id: `${floor}-${dir}`,
                    floor,
                    orientation: dir,
                    length: isLong ? dimensions.length : dimensions.width,
                    height: WALL_HEIGHT,
                    area: (isLong ? dimensions.length : dimensions.width) * WALL_HEIGHT
                });
            });
        });
        return walls;
    };

    // Helper to add feature
    const addFeature = (type) => {
        if (!selectedWall) return;
        setWallFeatures(prev => {
            const current = prev[selectedWall] || [];
            return { ...prev, [selectedWall]: [...current, { type, id: Date.now() }] };
        });
    };

    // Helper to remove feature
    const removeFeature = (wallId, featureId) => {
        setWallFeatures(prev => ({
            ...prev,
            [wallId]: prev[wallId].filter(f => f.id !== featureId)
        }));
    };

    const handleMaterialSelect = (materialId) => {
        if (selectionMode === 'exterior' && selectedWall) {
            setWallExterior(prev => ({ ...prev, [selectedWall]: materialId }));
        } else if (selectionMode === 'insulation' && selectedWall) {
            setWallInsulation(prev => ({ ...prev, [selectedWall]: materialId }));
        }
    };

    const getWallExterior = (wallId) => {
        const exteriorId = wallExterior[wallId] || 'brick-red';
        return EXTERIOR_MATERIALS.find(mat => mat.id === exteriorId) || EXTERIOR_MATERIALS[0];
    };

    const getWallInsulation = (wallId) => {
        const insulationId = wallInsulation[wallId] || 'none';
        return INSULATION_OPTIONS.find(opt => opt.id === insulationId);
    };

    // ---- UPDATED HVAC CALCULATIONS ----
    const calculateHVAC = () => {
        const walls = getWallData();
        let totalHeatLoss = 0;

        walls.forEach(wall => {
            // Get Features for this wall
            const features = wallFeatures[wall.id] || [];
            let featureArea = 0;
            let featureLoss = 0;
            const tempDiff = wall.floor === 'basement' ? (insideTemp - groundTemp) : (insideTemp - outsideTemp);

            // Calculate feature loss and total feature area
            features.forEach(f => {
                const stats = FEATURE_STATS[f.type];
                const area = stats.width * stats.height;
                featureArea += area;
                // Feature Loss = (Area / R) * DeltaT
                featureLoss += (area / stats.rValue) * tempDiff;
            });

            // Calculate Net Wall Area (Gross - Features)
            const netWallArea = Math.max(0, wall.area - featureArea);
            
            // Wall Calculation
            const insulation = getWallInsulation(wall.id);
            let rValue = insulation.rValue + 3; 
            
            if (wall.floor !== 'basement') {
                if (wall.orientation === windDirection) {
                    rValue = rValue * 0.85;
                }
            }

            const wallLoss = (netWallArea / rValue) * tempDiff;
            totalHeatLoss += Math.max(0, wallLoss + featureLoss);
        });

        // Conductive Loss (Roof)
        const roofArea = dimensions.length * dimensions.width;
        const roofRValue = 40; 
        const roofDiff = insideTemp - outsideTemp;
        totalHeatLoss += Math.max(0, (roofArea / roofRValue) * roofDiff);

        // Infiltration
        const volume = dimensions.length * dimensions.width * (floors.length * WALL_HEIGHT);
        const acph = 0.5 + (windSpeed * 0.05); 
        const infiltrationLoss = volume * 0.018 * (insideTemp - outsideTemp) * acph;
        totalHeatLoss += Math.max(0, infiltrationLoss);

        return Math.round(totalHeatLoss);
    };

    const btuRating = calculateHVAC();

    const renderFloorPlan = () => {
       const scale = 5;
       return (
            <svg width="800" height="600" className="border border-gray-300 bg-white">
                {floors.map((floor, floorIndex) => (
                    <g key={floor} transform={`translate(50, ${50 + floorIndex * 220})`}>
                        <text x={0} y={-10} fontSize="16" fontWeight="bold" className="uppercase">{floor} Floor</text>
                        <rect x={0} y={0} width={dimensions.length * scale} height={20} fill={`#${getWallInsulation(`${floor}-north`).color.toString(16).padStart(6, '0')}`} stroke="#1f2937" strokeWidth="2" className="cursor-pointer hover:opacity-80" onClick={() => setSelectedWall(`${floor}-north`)} />
                        <text x={dimensions.length * scale / 2} y={12} textAnchor="middle" fontSize="10" fill="#1f2937">N</text>
                        <rect x={0} y={dimensions.width * scale - 20} width={dimensions.length * scale} height={20} fill={`#${getWallInsulation(`${floor}-south`).color.toString(16).padStart(6, '0')}`} stroke="#1f2937" strokeWidth="2" className="cursor-pointer hover:opacity-80" onClick={() => setSelectedWall(`${floor}-south`)} />
                        <text x={dimensions.length * scale / 2} y={dimensions.width * scale - 8} textAnchor="middle" fontSize="10" fill="#1f2937">S</text>
                        <rect x={0} y={20} width={20} height={dimensions.width * scale - 40} fill={`#${getWallInsulation(`${floor}-west`).color.toString(16).padStart(6, '0')}`} stroke="#1f2937" strokeWidth="2" className="cursor-pointer hover:opacity-80" onClick={() => setSelectedWall(`${floor}-west`)} />
                        <text x={10} y={dimensions.width * scale / 2} textAnchor="middle" fontSize="10" fill="#1f2937">W</text>
                        <rect x={dimensions.length * scale - 20} y={20} width={20} height={dimensions.width * scale - 40} fill={`#${getWallInsulation(`${floor}-east`).color.toString(16).padStart(6, '0')}`} stroke="#1f2937" strokeWidth="2" className="cursor-pointer hover:opacity-80" onClick={() => setSelectedWall(`${floor}-east`)} />
                        <text x={dimensions.length * scale - 10} y={dimensions.width * scale / 2} textAnchor="middle" fontSize="10" fill="#1f2937">E</text>
                        <rect x={20} y={20} width={dimensions.length * scale - 40} height={dimensions.width * scale - 40} fill="#f3f4f6" stroke="none" />
                        <text x={dimensions.length * scale / 2} y={dimensions.width * scale + 20} textAnchor="middle" fontSize="12">{dimensions.length}' × {dimensions.width}'</text>
                    </g>
                ))}
            </svg>
        );
    };

    return (
        <div className="min-h-screen bg-gray-50 p-8">
            <div className="max-w-7xl mx-auto">
                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <div className="flex items-center gap-3 mb-6">
                        <div className="text-blue-600"><HomeIcon /></div>
                        <h1 className="text-3xl font-bold text-gray-900">Multi-Story House Builder & HVAC Calculator</h1>
                    </div>

                    {/* Main Grid Layout */}
                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                        {/* Left Column: 3D/Floor Plan */}
                        <div className="lg:col-span-2">
                            <div className="flex gap-2 mb-4">
                                <button onClick={() => setViewMode('3d')} className={`px-4 py-2 rounded-lg font-medium transition-colors ${viewMode === '3d' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>3D View</button>
                                <button onClick={() => setViewMode('floor')} className={`px-4 py-2 rounded-lg font-medium transition-colors ${viewMode === 'floor' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>Floor Plan View</button>
                            </div>

                            <div className="mb-6 flex justify-center">
                                {viewMode === '3d' ? (
                                    <div>
                                        <div ref={mountRef} className="border-4 border-gray-300 rounded-lg"></div>
                                        <p className="text-xs text-gray-500 mt-2 text-center">Drag to rotate • Right-click to pan • Scroll to zoom</p>
                                    </div>
                                ) : (
                                    renderFloorPlan()
                                )}
                            </div>
                            
                            {/* Dimensions */}
                            <div className="grid grid-cols-2 gap-4 mb-6">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">Length (ft)</label>
                                    <input type="number" value={dimensions.length} onChange={(e) => setDimensions(prev => ({ ...prev, length: parseInt(e.target.value) || 0 }))} className="w-full px-4 py-2 border border-gray-300 rounded-lg" min="10" max="100" />
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">Width (ft)</label>
                                    <input type="number" value={dimensions.width} onChange={(e) => setDimensions(prev => ({ ...prev, width: parseInt(e.target.value) || 0 }))} className="w-full px-4 py-2 border border-gray-300 rounded-lg" min="10" max="100" />
                                </div>
                            </div>
                        </div>

                        {/* Right Column: HVAC Controls & Materials */}
                        <div className="space-y-6">
                            
                            {/* HVAC CALCULATOR PANEL */}
                            <div className="bg-orange-50 border border-orange-200 rounded-lg p-5">
                                <h3 className="text-lg font-bold text-orange-900 mb-4 flex items-center gap-2">
                                    <FireIcon /> Heating Req.
                                </h3>
                                
                                <div className="space-y-4">
                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="block text-xs font-semibold text-orange-800 mb-1">Outside Temp (°F)</label>
                                            <input type="number" value={outsideTemp} onChange={(e) => setOutsideTemp(Number(e.target.value))} className="w-full px-2 py-1 border border-orange-200 rounded text-sm" />
                                        </div>
                                        <div>
                                            <label className="block text-xs font-semibold text-orange-800 mb-1">Ground Temp (°F)</label>
                                            <input type="number" value={groundTemp} onChange={(e) => setGroundTemp(Number(e.target.value))} className="w-full px-2 py-1 border border-orange-200 rounded text-sm" />
                                        </div>
                                        <div>
                                            <label className="block text-xs font-semibold text-orange-800 mb-1">Inside Temp (°F)</label>
                                            <input type="number" value={insideTemp} onChange={(e) => setInsideTemp(Number(e.target.value))} className="w-full px-2 py-1 border border-orange-200 rounded text-sm" />
                                        </div>
                                        <div>
                                            <label className="block text-xs font-semibold text-orange-800 mb-1">Wind Speed (mph)</label>
                                            <input type="number" value={windSpeed} onChange={(e) => setWindSpeed(Number(e.target.value))} className="w-full px-2 py-1 border border-orange-200 rounded text-sm" />
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <label className="block text-xs font-semibold text-orange-800 mb-1">Wind Direction</label>
                                        <select value={windDirection} onChange={(e) => setWindDirection(e.target.value)} className="w-full px-2 py-1 border border-orange-200 rounded text-sm bg-white">
                                            <option value="north">North</option>
                                            <option value="south">South</option>
                                            <option value="east">East</option>
                                            <option value="west">West</option>
                                        </select>
                                    </div>

                                    <div className="mt-4 pt-4 border-t border-orange-200">
                                        <div className="text-sm text-orange-800">Required Furnace Rating:</div>
                                        <div className="text-3xl font-black text-orange-600">{btuRating.toLocaleString()} BTU/hr</div>
                                        <div className="text-xs text-orange-700 mt-1 italic">Includes Wall/Roof conduction + Wind Infiltration</div>
                                    </div>
                                </div>
                            </div>

                            {/* Selection Controls */}
                            <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                                {selectedWall ? (
                                    <div className="mb-4">
                                        <h3 className="font-semibold text-gray-900">Edit: {selectedWall.toUpperCase()}</h3>
                                        <p className="text-xs text-gray-600 mb-2">Current R-Value: {getWallInsulation(selectedWall).rValue + 3} (Total)</p>
                                    </div>
                                ) : (
                                    <div className="mb-4 text-sm text-gray-500 italic">Select a wall to edit materials</div>
                                )}

                                <div className="flex gap-2 mb-4">
                                    <button onClick={() => setSelectionMode('exterior')} className={`flex-1 px-2 py-1 rounded text-sm font-medium transition-colors ${selectionMode === 'exterior' ? 'bg-gray-800 text-white' : 'bg-gray-200'}`}>Exterior</button>
                                    <button onClick={() => setSelectionMode('insulation')} className={`flex-1 px-2 py-1 rounded text-sm font-medium transition-colors ${selectionMode === 'insulation' ? 'bg-gray-800 text-white' : 'bg-gray-200'}`}>Insulation</button>
                                    <button onClick={() => setSelectionMode('features')} className={`flex-1 px-2 py-1 rounded text-sm font-medium transition-colors ${selectionMode === 'features' ? 'bg-gray-800 text-white' : 'bg-gray-200'}`}>Features</button>
                                </div>

                                <div className="h-64 overflow-y-auto">
                                    {selectionMode === 'exterior' && (
                                        <div className="grid grid-cols-2 gap-2">
                                            {EXTERIOR_MATERIALS.map(material => (
                                                <button key={material.id} onClick={() => handleMaterialSelect(material.id)} disabled={!selectedWall} className={`p-2 rounded border text-left ${selectedWall && wallExterior[selectedWall] === material.id ? 'border-green-600 bg-green-50' : 'border-gray-300'} ${!selectedWall && 'opacity-50'}`}>
                                                    <div className="w-full h-4 rounded mb-1" style={{ backgroundColor: `#${material.color.toString(16).padStart(6, '0')}` }}></div>
                                                    <div className="text-xs font-medium">{material.name}</div>
                                                </button>
                                            ))}
                                        </div>
                                    )}

                                    {selectionMode === 'insulation' && (
                                        <div className="grid grid-cols-1 gap-2">
                                            {INSULATION_OPTIONS.map(option => (
                                                <button key={option.id} onClick={() => handleMaterialSelect(option.id)} disabled={!selectedWall} className={`p-2 rounded border text-left flex justify-between items-center ${selectedWall && wallInsulation[selectedWall] === option.id ? 'border-blue-600 bg-blue-50' : 'border-gray-300'} ${!selectedWall && 'opacity-50'}`}>
                                                    <div>
                                                        <div className="text-xs font-medium">{option.name}</div>
                                                        <div className="text-xs text-gray-500">R-{option.rValue}</div>
                                                    </div>
                                                    <div className="w-4 h-4 rounded-full" style={{ backgroundColor: `#${option.color.toString(16).padStart(6, '0')}` }}></div>
                                                </button>
                                            ))}
                                        </div>
                                    )}

                                    {selectionMode === 'features' && selectedWall && (
                                        <div className="space-y-2">
                                            <div className="flex gap-1">
                                                <button onClick={()=>addFeature('window-std')} className="flex-1 bg-green-100 p-2 text-xs border border-green-300 rounded hover:bg-green-200 font-bold">+ Win</button>
                                                <button onClick={()=>addFeature('window-pic')} className="flex-1 bg-green-100 p-2 text-xs border border-green-300 rounded hover:bg-green-200 font-bold">+ Pic</button>
                                                <button onClick={()=>addFeature('door')} className="flex-1 bg-amber-100 p-2 text-xs border border-amber-300 rounded hover:bg-amber-200 font-bold">+ Door</button>
                                            </div>
                                            
                                            <div className="mt-2 border-t pt-2">
                                                <div className="text-xs font-bold text-gray-500 mb-1">Current Features:</div>
                                                {(wallFeatures[selectedWall] || []).map((f, i) => (
                                                    <div key={f.id} className="flex justify-between items-center bg-white p-2 mb-1 rounded border text-xs">
                                                        <span>{FEATURE_STATS[f.type].name}</span>
                                                        <button onClick={()=>removeFeature(selectedWall, f.id)} className="text-red-500 hover:bg-red-50 rounded p-1"><TrashIcon/></button>
                                                    </div>
                                                ))}
                                                {(!wallFeatures[selectedWall] || wallFeatures[selectedWall].length === 0) && <div className="text-xs italic text-gray-400">No features added</div>}
                                            </div>
                                        </div>
                                    )}
                                    {selectionMode === 'features' && !selectedWall && <div className="text-xs text-gray-400 italic">Select a wall to add features</div>}
                                </div>
                            </div>
                            
                            {/* Roof Material Selector */}
                            <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                                <h3 className="text-sm font-semibold mb-2">Roof Material</h3>
                                <div className="grid grid-cols-2 gap-2">
                                    {ROOF_MATERIALS.map(material => (
                                        <button key={material.id} onClick={() => setRoofMaterial(material.id)} className={`p-2 rounded border text-left ${roofMaterial === material.id ? 'border-purple-600 bg-purple-50' : 'border-gray-300'}`}>
                                            <div className="w-full h-4 rounded mb-1" style={{ backgroundColor: `#${material.color.toString(16).padStart(6, '0')}` }}></div>
                                            <div className="text-xs font-medium">{material.name}</div>
                                        </button>
                                    ))}
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<HouseBuilder />);


    </script>
</body>
</html>







