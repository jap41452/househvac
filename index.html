<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Story House Builder</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">


const { useState, useEffect, useRef } = React;

        // --- CONSTANTS ---
        const INSULATION_OPTIONS = [
            { id: 'none', name: 'No Insulation', rValue: 2, color: 0xe5e7eb },
            { id: 'fiberglass-r13', name: 'Fiberglass Batt R-13', rValue: 13, color: 0xfbbf24 },
            { id: 'fiberglass-r19', name: 'Fiberglass Batt R-19', rValue: 19, color: 0xf59e0b },
            { id: 'spray-foam-r25', name: 'Spray Foam R-25', rValue: 25, color: 0x10b981 },
        ];

        const EXTERIOR_MATERIALS = [
            { id: 'brick-red', name: 'Red Brick', color: 0x8B4513 },
            { id: 'vinyl-white', name: 'White Vinyl Siding', color: 0xF5F5F5 },
            { id: 'vinyl-gray', name: 'Gray Vinyl Siding', color: 0x808080 },
            { id: 'clapboard-blue', name: 'Blue Clapboard', color: 0x4682B4 },
            { id: 'stucco-tan', name: 'Tan Stucco', color: 0xD2B48C },
        ];

        const ROOF_MATERIALS = [
            { id: 'asphalt-gray', name: 'Gray Asphalt', color: 0x808080 },
            { id: 'metal-silver', name: 'Silver Metal', color: 0xC0C0C0 },
        ];

        // R-Values for features
        const FEATURE_STATS = {
            'window-std': { name: 'Std Window', rValue: 3, width: 3, height: 4, color: 0x87ceeb },
            'window-pic': { name: 'Picture Window', rValue: 3, width: 6, height: 5, color: 0x87ceeb },
            'door': { name: 'Door', rValue: 5, width: 3, height: 7, color: 0x8b4513 }
        };

        // Icons
        const HomeIcon = () => (<svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" /></svg>);
        const FireIcon = () => (<svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.879 16.121A3 3 0 1012.015 11L11 14H9c0 .768.293 1.536.879 2.121z" /></svg>);
        const TrashIcon = () => (<svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>);

        // OrbitControls Class
        class OrbitControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.target = new THREE.Vector3(0, 0, 0); 
                this.minDistance = 20;
                this.maxDistance = 200;
                this.rotateSpeed = 0.5;
                this.spherical = new THREE.Spherical();
                this.sphericalDelta = new THREE.Spherical();
                this.scale = 1;
                this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this));
            }
            onMouseDown(event) {
                if (event.button === 0) {
                    this.state = 'rotate';
                    this.rotateStart = new THREE.Vector2(event.clientX, event.clientY);
                    this.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                    this.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
                }
            }
            onMouseMove(event) {
                if (this.state === 'rotate') {
                    const rotateEnd = new THREE.Vector2(event.clientX, event.clientY);
                    const delta = new THREE.Vector2().subVectors(rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);
                    this.sphericalDelta.theta -= 2 * Math.PI * delta.x / this.domElement.clientHeight;
                    this.sphericalDelta.phi -= 2 * Math.PI * delta.y / this.domElement.clientHeight;
                    this.rotateStart.copy(rotateEnd);
                    this.update();
                }
            }
            onMouseUp() {
                this.domElement.removeEventListener('mousemove', this.onMouseMove.bind(this));
                this.domElement.removeEventListener('mouseup', this.onMouseUp.bind(this));
            }
            onMouseWheel(event) {
                if (event.deltaY < 0) this.scale /= 0.95; else this.scale *= 0.95;
                this.update();
            }
            update() {
                const offset = new THREE.Vector3().copy(this.camera.position).sub(this.target);
                this.spherical.setFromVector3(offset);
                this.spherical.theta += this.sphericalDelta.theta;
                this.spherical.phi += this.sphericalDelta.phi;
                this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));
                this.spherical.radius *= this.scale;
                offset.setFromSpherical(this.spherical);
                this.camera.position.copy(this.target).add(offset);
                this.camera.lookAt(this.target);
                this.sphericalDelta.set(0, 0, 0);
                this.scale = 1;
            }
        }

        function HouseBuilder() {
            const [dimensions, setDimensions] = useState({ length: 40, width: 30 });
            const [selectedWall, setSelectedWall] = useState(null);
            const [wallInsulation, setWallInsulation] = useState({});
            const [wallExterior, setWallExterior] = useState({});
            const [wallFeatures, setWallFeatures] = useState({}); 
            const [roofMaterial, setRoofMaterial] = useState('asphalt-gray');
            const [viewMode, setViewMode] = useState('3d');
            const [selectionMode, setSelectionMode] = useState('exterior');
            
            // Env State
            const [outsideTemp, setOutsideTemp] = useState(32); 
            const [groundTemp, setGroundTemp] = useState(50);
            const [insideTemp, setInsideTemp] = useState(70);
            const [windSpeed, setWindSpeed] = useState(10);
            const [windDirection, setWindDirection] = useState('north');

            const mountRef = useRef(null);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const wallMeshesRef = useRef({});

            const WALL_HEIGHT = 9;
            const ROOF_PITCH = 3/8;
            const floors = ['basement', 'first', 'second'];

            useEffect(() => {
                if (viewMode !== '3d' || !mountRef.current) return;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87ceeb);
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(60, 800 / 600, 0.1, 1000);
                camera.position.set(60, 20, 60); 
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(800, 600);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                const controls = new OrbitControls(camera, renderer.domElement);
                controls.update();

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
                sunLight.position.set(50, 80, 50);
                sunLight.castShadow = true;
                scene.add(sunLight);

                // --- PHANTOM GROUND ---
                const groundGeometry = new THREE.PlaneGeometry(200, 200);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x3a7d3a, 
                    roughness: 0.8,
                    side: THREE.DoubleSide,
                    transparent: true, 
                    opacity: 0.4       
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);

                // Grid helper
                const gridHelper = new THREE.GridHelper(100, 50, 0x000000, 0x000000);
                gridHelper.material.opacity = 0.2;
                gridHelper.material.transparent = true;
                scene.add(gridHelper);

                buildHouse();

                function animate() {
                    requestAnimationFrame(animate);
                    renderer.render(scene, camera);
                }
                animate();

                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                function onMouseClick(event) {
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(Object.values(wallMeshesRef.current));

                    if (intersects.length > 0) {
                        let target = intersects[0].object;
                        while(target.parent && !target.userData.wallId) {
                            target = target.parent;
                        }
                        if (target.userData.wallId) {
                            setSelectedWall(target.userData.wallId);
                        }
                    }
                }

                renderer.domElement.addEventListener('click', onMouseClick);

                return () => {
                    renderer.domElement.removeEventListener('click', onMouseClick);
                    mountRef.current?.removeChild(renderer.domElement);
                    renderer.dispose();
                };
            }, [viewMode]);

            useEffect(() => {
                if (viewMode === '3d') buildHouse();
            }, [dimensions, wallInsulation, wallExterior, roofMaterial, wallFeatures]);

            const buildHouse = () => {
                if (!sceneRef.current) return;
                Object.values(wallMeshesRef.current).forEach(mesh => sceneRef.current.remove(mesh));
                sceneRef.current.children = sceneRef.current.children.filter(c => c.type !== 'Mesh' || c.geometry.type === 'PlaneGeometry' && c.rotation.x === -Math.PI/2); 

                wallMeshesRef.current = {};
                const wallThickness = 0.5;
                
                floors.forEach((floor, floorIndex) => {
                    const floorY = (floorIndex - 1) * WALL_HEIGHT;
                    const isBasement = floor === 'basement';

                    // Floor Plate
                    const floorMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(dimensions.length, 0.5, dimensions.width),
                        new THREE.MeshStandardMaterial({ color: 0x8b7355 })
                    );
                    floorMesh.position.set(0, floorY, 0);
                    sceneRef.current.add(floorMesh);

                    // Walls
                    const directions = [
                        { id: 'north', pos: [0, floorY + WALL_HEIGHT/2, -dimensions.width/2], dim: [dimensions.length, WALL_HEIGHT, wallThickness], rotY: 0 },
                        { id: 'south', pos: [0, floorY + WALL_HEIGHT/2, dimensions.width/2], dim: [dimensions.length, WALL_HEIGHT, wallThickness], rotY: Math.PI },
                        { id: 'east', pos: [dimensions.length/2, floorY + WALL_HEIGHT/2, 0], dim: [wallThickness, WALL_HEIGHT, dimensions.width], rotY: -Math.PI/2 },
                        { id: 'west', pos: [-dimensions.length/2, floorY + WALL_HEIGHT/2, 0], dim: [wallThickness, WALL_HEIGHT, dimensions.width], rotY: Math.PI/2 },
                    ];

                    directions.forEach(dir => {
                        const wallId = `${floor}-${dir.id}`;
                        const exterior = getWallExterior(wallId);
                        
                        let material;
                        if (isBasement) {
                            material = new THREE.MeshPhysicalMaterial({
                                color: 0x708090, 
                                transparent: true,
                                opacity: 0.7,
                                roughness: 0.5,
                                metalness: 0.1
                            });
                        } else {
                            material = new THREE.MeshStandardMaterial({ color: exterior.color });
                        }

                        const mesh = new THREE.Mesh(new THREE.BoxGeometry(...dir.dim), material);
                        mesh.position.set(...dir.pos);
                        mesh.castShadow = !isBasement;
                        mesh.receiveShadow = true;
                        mesh.userData.wallId = wallId;
                        sceneRef.current.add(mesh);
                        wallMeshesRef.current[wallId] = mesh;

                        // Stickers
                        const features = wallFeatures[wallId] || [];
                        const wallWidth = dir.id === 'north' || dir.id === 'south' ? dimensions.length : dimensions.width;
                        const spacing = wallWidth / (features.length + 1);

                        features.forEach((feature, idx) => {
                            const stats = FEATURE_STATS[feature.type];
                            const featureGeom = new THREE.BoxGeometry(
                                dir.id === 'north' || dir.id === 'south' ? stats.width : wallThickness + 0.2, 
                                stats.height, 
                                dir.id === 'north' || dir.id === 'south' ? wallThickness + 0.2 : stats.width
                            );
                            
                            const featureMat = new THREE.MeshStandardMaterial({ 
                                color: stats.color,
                                roughness: 0.2,
                                metalness: 0.8 
                            });
                            
                            const featureMesh = new THREE.Mesh(featureGeom, featureMat);
                            const offset = -wallWidth/2 + (spacing * (idx + 1));
                            
                            let fx = 0, fz = 0;
                            const yOffset = feature.type.includes('door') ? (-WALL_HEIGHT/2 + stats.height/2) : 0; 

                            if (dir.id === 'north') { fx = offset; fz = 0; }
                            if (dir.id === 'south') { fx = -offset; fz = 0; } 
                            if (dir.id === 'east')  { fx = 0; fz = -offset; }
                            if (dir.id === 'west')  { fx = 0; fz = offset; }

                            featureMesh.position.set(
                                mesh.position.x + fx, 
                                mesh.position.y + yOffset, 
                                mesh.position.z + fz
                            );
                            sceneRef.current.add(featureMesh);
                        });
                    });

                    const trim = new THREE.Mesh(
                        new THREE.BoxGeometry(dimensions.length + 0.8, 0.4, dimensions.width + 0.8),
                        new THREE.MeshStandardMaterial({ color: 0xFFFFFF })
                    );
                    trim.position.set(0, floorY + WALL_HEIGHT, 0);
                    sceneRef.current.add(trim);
                });

                // Roof
                const roofY = (floors.length - 1) * WALL_HEIGHT; 
                const roofRise = (dimensions.width / 2) * ROOF_PITCH;
                
                const gableGeo = new THREE.ShapeGeometry(new THREE.Shape().moveTo(-dimensions.width/2,0).lineTo(dimensions.width/2,0).lineTo(0,roofRise));
                const gableMat = new THREE.MeshStandardMaterial({ color: 0xE8E8E8, side: THREE.DoubleSide });
                const wGable = new THREE.Mesh(gableGeo, gableMat);
                wGable.position.set(-dimensions.length/2, roofY, 0); wGable.rotation.y = Math.PI/2;
                sceneRef.current.add(wGable);
                const eGable = new THREE.Mesh(gableGeo, gableMat);
                eGable.position.set(dimensions.length/2, roofY, 0); eGable.rotation.y = -Math.PI/2;
                sceneRef.current.add(eGable);

                const roofLen = Math.sqrt((dimensions.width/2)**2 + roofRise**2);
                const roofAng = Math.atan2(roofRise, dimensions.width/2);
                const roofMeshMat = new THREE.MeshStandardMaterial({ color: 0x808080, side: THREE.DoubleSide });
                
                const nRoof = new THREE.Mesh(new THREE.PlaneGeometry(dimensions.length+1, roofLen), roofMeshMat);
                nRoof.position.set(0, roofY+roofRise/2, -dimensions.width/4); nRoof.rotation.x = -Math.PI/2 - roofAng;
                sceneRef.current.add(nRoof);
                
                const sRoof = new THREE.Mesh(new THREE.PlaneGeometry(dimensions.length+1, roofLen), roofMeshMat);
                sRoof.position.set(0, roofY+roofRise/2, dimensions.width/4); sRoof.rotation.x = -Math.PI/2 + roofAng;
                sceneRef.current.add(sRoof);
            };

            const addFeature = (type) => {
                if (!selectedWall) return;
                setWallFeatures(prev => {
                    const current = prev[selectedWall] || [];
                    return { ...prev, [selectedWall]: [...current, { type, id: Date.now() }] };
                });
            };

            const removeFeature = (wallId, featureId) => {
                setWallFeatures(prev => ({
                    ...prev,
                    [wallId]: prev[wallId].filter(f => f.id !== featureId)
                }));
            };

            const getWallExterior = (wallId) => {
                const ex = wallExterior[wallId] || 'brick-red';
                return EXTERIOR_MATERIALS.find(m => m.id === ex) || EXTERIOR_MATERIALS[0];
            };
            
            const getWallInsulation = (wallId) => {
                const ins = wallInsulation[wallId] || 'none';
                return INSULATION_OPTIONS.find(m => m.id === ins) || INSULATION_OPTIONS[0];
            };

            const calculateHVAC = () => {
                let totalHeatLoss = 0;
                floors.forEach(floor => {
                    ['north','south','east','west'].forEach(dir => {
                        const wallId = `${floor}-${dir}`;
                        const isLong = dir === 'north' || dir === 'south';
                        const wallL = isLong ? dimensions.length : dimensions.width;
                        const grossArea = wallL * WALL_HEIGHT;
                        
                        const features = wallFeatures[wallId] || [];
                        let featureArea = 0;
                        let featureLoss = 0;
                        
                        const tempDiff = floor === 'basement' ? (insideTemp - groundTemp) : (insideTemp - outsideTemp);
                        
                        features.forEach(f => {
                            const stats = FEATURE_STATS[f.type];
                            const area = stats.width * stats.height;
                            featureArea += area;
                            featureLoss += (area / stats.rValue) * tempDiff;
                        });

                        const netArea = Math.max(0, grossArea - featureArea);
                        const ins = wallInsulation[wallId] || 'none';
                        const rValBase = INSULATION_OPTIONS.find(i=>i.id===ins).rValue + 3; 
                        
                        const rValEff = (dir === windDirection && floor !== 'basement') ? rValBase * 0.85 : rValBase;
                        const wallLoss = (netArea / rValEff) * tempDiff;
                        
                        totalHeatLoss += wallLoss + featureLoss;
                    });
                });

                const roofArea = dimensions.length * dimensions.width;
                totalHeatLoss += (roofArea / 40) * (insideTemp - outsideTemp);

                const vol = dimensions.length * dimensions.width * (floors.length * WALL_HEIGHT);
                const acph = 0.5 + (windSpeed * 0.05);
                totalHeatLoss += vol * 0.018 * (insideTemp - outsideTemp) * acph;

                return Math.max(0, Math.round(totalHeatLoss));
            };
            
            const renderFloorPlan = () => {
               const scale = 5;
               return (
                    <svg width="800" height="600" className="border border-gray-300 bg-white">
                        {floors.map((floor, floorIndex) => (
                            <g key={floor} transform={`translate(50, ${50 + floorIndex * 220})`}>
                                <text x={0} y={-10} fontSize="16" fontWeight="bold" className="uppercase">{floor} Floor</text>
                                <rect x={0} y={0} width={dimensions.length * scale} height={20} fill={`#${getWallInsulation(`${floor}-north`).color.toString(16).padStart(6, '0')}`} stroke="#1f2937" strokeWidth="2" className="cursor-pointer hover:opacity-80" onClick={() => setSelectedWall(`${floor}-north`)} />
                                <text x={dimensions.length * scale / 2} y={12} textAnchor="middle" fontSize="10" fill="#1f2937">N</text>
                                <rect x={0} y={dimensions.width * scale - 20} width={dimensions.length * scale} height={20} fill={`#${getWallInsulation(`${floor}-south`).color.toString(16).padStart(6, '0')}`} stroke="#1f2937" strokeWidth="2" className="cursor-pointer hover:opacity-80" onClick={() => setSelectedWall(`${floor}-south`)} />
                                <text x={dimensions.length * scale / 2} y={dimensions.width * scale - 8} textAnchor="middle" fontSize="10" fill="#1f2937">S</text>
                                <rect x={0} y={20} width={20} height={dimensions.width * scale - 40} fill={`#${getWallInsulation(`${floor}-west`).color.toString(16).padStart(6, '0')}`} stroke="#1f2937" strokeWidth="2" className="cursor-pointer hover:opacity-80" onClick={() => setSelectedWall(`${floor}-west`)} />
                                <text x={10} y={dimensions.width * scale / 2} textAnchor="middle" fontSize="10" fill="#1f2937">W</text>
                                <rect x={dimensions.length * scale - 20} y={20} width={20} height={dimensions.width * scale - 40} fill={`#${getWallInsulation(`${floor}-east`).color.toString(16).padStart(6, '0')}`} stroke="#1f2937" strokeWidth="2" className="cursor-pointer hover:opacity-80" onClick={() => setSelectedWall(`${floor}-east`)} />
                                <text x={dimensions.length * scale - 10} y={dimensions.width * scale / 2} textAnchor="middle" fontSize="10" fill="#1f2937">E</text>
                                <rect x={20} y={20} width={dimensions.length * scale - 40} height={dimensions.width * scale - 40} fill="#f3f4f6" stroke="none" />
                                <text x={dimensions.length * scale / 2} y={dimensions.width * scale + 20} textAnchor="middle" fontSize="12">{dimensions.length}' × {dimensions.width}'</text>
                            </g>
                        ))}
                    </svg>
                );
            };

            return (
                <div className="min-h-screen bg-gray-50 p-8">
                    <div className="max-w-7xl mx-auto">
                        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                            <div className="flex justify-between items-center mb-6">
                                <div className="flex items-center gap-3">
                                    <div className="text-blue-600"><HomeIcon /></div>
                                    <h1 className="text-3xl font-bold text-gray-900">HVAC Builder v3</h1>
                                </div>
                                <div className="bg-orange-100 px-4 py-2 rounded-lg border border-orange-300">
                                    <div className="text-xs text-orange-800 font-bold uppercase">Total Load</div>
                                    <div className="text-2xl font-black text-orange-600">{calculateHVAC().toLocaleString()} BTU/hr</div>
                                </div>
                            </div>

                            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                                {/* Left: View */}
                                <div className="lg:col-span-2">
                                     <div className="flex gap-2 mb-4">
                                        <button onClick={() => setViewMode('3d')} className={`px-4 py-2 rounded-lg font-medium transition-colors ${viewMode === '3d' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>3D View</button>
                                        <button onClick={() => setViewMode('floor')} className={`px-4 py-2 rounded-lg font-medium transition-colors ${viewMode === 'floor' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>Floor Plan View</button>
                                    </div>
                                    
                                    {viewMode === '3d' ? (
                                        <>
                                            <div ref={mountRef} className="h-96 w-full border-4 border-gray-300 rounded-lg bg-blue-50"></div>
                                            <div className="flex gap-4 mt-4 text-sm text-gray-600 justify-center">
                                                <span>Left-Click: Rotate</span>
                                                <span>Right-Click: Pan</span>
                                                <span>Scroll: Zoom</span>
                                                <span>Click Walls to Select</span>
                                            </div>
                                        </>
                                    ) : (
                                        <div className="overflow-auto h-96 border-4 border-gray-300 rounded-lg p-4">
                                            {renderFloorPlan()}
                                        </div>
                                    )}
                                </div>

                                {/* Right: Controls */}
                                <div className="space-y-4 h-[32rem] overflow-y-auto pr-2">
                                    {/* Env Controls - RESTORED */}
                                    <div className="bg-gray-100 p-3 rounded text-sm">
                                        <h3 className="font-bold mb-2">Environment</h3>
                                        <div className="grid grid-cols-2 gap-2 mb-2">
                                            <div><label>Outside °F</label><input type="number" value={outsideTemp} onChange={e=>setOutsideTemp(Number(e.target.value))} className="w-full p-1 border rounded"/></div>
                                            <div><label>Inside °F</label><input type="number" value={insideTemp} onChange={e=>setInsideTemp(Number(e.target.value))} className="w-full p-1 border rounded"/></div>
                                        </div>
                                        <div className="grid grid-cols-2 gap-2 mb-2">
                                            <div><label>Ground °F</label><input type="number" value={groundTemp} onChange={e=>setGroundTemp(Number(e.target.value))} className="w-full p-1 border rounded"/></div>
                                            <div><label>Wind mph</label><input type="number" value={windSpeed} onChange={e=>setWindSpeed(Number(e.target.value))} className="w-full p-1 border rounded"/></div>
                                        </div>
                                         <div className="mb-2">
                                            <label>Wind Direction</label>
                                            <select value={windDirection} onChange={(e) => setWindDirection(e.target.value)} className="w-full p-1 border rounded">
                                                <option value="north">North</option>
                                                <option value="south">South</option>
                                                <option value="east">East</option>
                                                <option value="west">West</option>
                                            </select>
                                        </div>
                                    </div>

                                    {/* Wall Editor */}
                                    {selectedWall ? (
                                        <div className="bg-blue-50 p-3 rounded border border-blue-200">
                                            <h3 className="font-bold text-blue-900 mb-2">Edit: {selectedWall}</h3>
                                            
                                            <div className="flex gap-2 mb-3">
                                                <button onClick={()=>setSelectionMode('exterior')} className={`flex-1 text-xs py-1 rounded ${selectionMode==='exterior'?'bg-blue-600 text-white':'bg-white'}`}>Ext</button>
                                                <button onClick={()=>setSelectionMode('insulation')} className={`flex-1 text-xs py-1 rounded ${selectionMode==='insulation'?'bg-blue-600 text-white':'bg-white'}`}>Insul</button>
                                                <button onClick={()=>setSelectionMode('features')} className={`flex-1 text-xs py-1 rounded ${selectionMode==='features'?'bg-blue-600 text-white':'bg-white'}`}>Feat.</button>
                                            </div>

                                            {selectionMode === 'exterior' && (
                                                <div className="grid grid-cols-2 gap-1">
                                                    {EXTERIOR_MATERIALS.map(m => (
                                                        <button key={m.id} onClick={()=>setWallExterior({...wallExterior, [selectedWall]: m.id})} className="text-xs p-1 bg-white border rounded text-left">{m.name}</button>
                                                    ))}
                                                </div>
                                            )}

                                             {selectionMode === 'insulation' && (
                                                <div className="grid grid-cols-1 gap-1">
                                                    {INSULATION_OPTIONS.map(m => (
                                                        <button key={m.id} onClick={()=>setWallInsulation({...wallInsulation, [selectedWall]: m.id})} className="text-xs p-1 bg-white border rounded text-left flex justify-between">
                                                            <span>{m.name}</span>
                                                            <span className="text-gray-500">R-{m.rValue}</span>
                                                        </button>
                                                    ))}
                                                </div>
                                            )}

                                            {selectionMode === 'features' && (
                                                <div className="space-y-2">
                                                    <div className="flex gap-1">
                                                        <button onClick={()=>addFeature('window-std')} className="flex-1 bg-green-100 p-1 text-xs border border-green-300 rounded hover:bg-green-200">+ Std</button>
                                                        <button onClick={()=>addFeature('window-pic')} className="flex-1 bg-green-100 p-1 text-xs border border-green-300 rounded hover:bg-green-200">+ Pic</button>
                                                        <button onClick={()=>addFeature('door')} className="flex-1 bg-amber-100 p-1 text-xs border border-amber-300 rounded hover:bg-amber-200">+ Door</button>
                                                    </div>
                                                    
                                                    <div className="mt-2 border-t pt-2">
                                                        <div className="text-xs font-bold text-gray-500 mb-1">Current Features:</div>
                                                        {(wallFeatures[selectedWall] || []).map((f, i) => (
                                                            <div key={f.id} className="flex justify-between items-center bg-white p-1 mb-1 rounded border text-xs">
                                                                <span>{FEATURE_STATS[f.type].name}</span>
                                                                <button onClick={()=>removeFeature(selectedWall, f.id)} className="text-red-500"><TrashIcon/></button>
                                                            </div>
                                                        ))}
                                                        {(!wallFeatures[selectedWall] || wallFeatures[selectedWall].length === 0) && <div className="text-xs italic text-gray-400">None</div>}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    ) : (
                                        <div className="p-4 text-center text-gray-500 italic border rounded">Select a wall to add windows/doors</div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<HouseBuilder />);


    </script>
</body>
</html>





